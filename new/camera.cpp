//=============================================================================
//
// カメラ処理 [camera.cpp]
//
//=============================================================================
#include "main.h"
#include "input.h"
#include "camera.h"
#include "debugproc.h"
#include "player.h"
#include "game.h"


//*****************************************************************************
// マクロ定義
//*****************************************************************************
#define	VIEW_ANGLE		(XMConvertToRadians(45.0f))						// ビュー平面の視野角
#define	VIEW_ASPECT		((float)SCREEN_WIDTH / (float)SCREEN_HEIGHT)	// ビュー平面のアスペクト比	
#define	VIEW_NEAR_Z		(10.0f)											// ビュー平面のNearZ値
#define	VIEW_FAR_Z		(10000.0f)										// ビュー平面のFarZ値

#define	VALUE_MOVE_CAMERA	(2.0f)										// カメラの移動量
#define	VALUE_ROTATE_CAMERA	(XM_PI * 0.01f)								// カメラの回転量

//*****************************************************************************
// グローバル変数
//*****************************************************************************
static CAMERA			g_Camera;		// カメラデータ

static int				g_ViewPortType = TYPE_FULL_SCREEN;

float g_Camera_at_rot = 0.0f;

XMFLOAT3 OnePerson = {8.0f,10.0f,8.0f };
XMFLOAT3 ThirdPerson = { 70.0f,20.0f,70.0f };

//人称フラグ true:三人称 false:一人称
bool ViewType = false;

//=============================================================================
// 初期化処理
//=============================================================================
void InitCamera(void)
{
	g_Camera.pos = { 0.0f, 0.0f, 0.0f };
	g_Camera.at = { 0.0f, 0.0f, 0.0f };
	g_Camera.up = { 0.0f, 1.0f, 0.0f };
	g_Camera.rot = { 0.0f, 0.0f, 0.0f };

	// 視点と注視点の距離を計算
	g_Camera.len = 200.0f;

	// ビューポートタイプの初期化
	g_ViewPortType = TYPE_FULL_SCREEN;
}


//=============================================================================
// カメラの終了処理
//=============================================================================
void UninitCamera(void)
{

}


//=============================================================================
// カメラの更新処理
//=============================================================================
void UpdateCamera(void)
{
	//マウスの移動命令
	{
		long diff_X = GetMousePosX() - SCREEN_CENTER_X; //diff_X > 0  右側  diff_X < 0  左側
		long diff_Y = GetMousePosY() - SCREEN_CENTER_Y; //diff_Y > 0  下側  diff_Y < 0  上側

		g_Camera.rot.y += XM_PI * diff_X * 0.005f;

		if (g_Camera_at_rot <= XM_PI / 2 && g_Camera_at_rot >= -XM_PI / 4)
		{
			g_Camera_at_rot += XM_PI * diff_Y * 0.002f;
		}
		else if (g_Camera_at_rot > XM_PI / 2)
		{
			g_Camera_at_rot = XM_PI / 2;
		}
		else
		{
			g_Camera_at_rot = -XM_PI / 4;
		}
	}

#ifdef _DEBUG
	if (GetKeyboardTrigger(DIK_F3))
	{
		//人称フラグ true:三人称 false:一人称
		ViewType = ViewType ? false : true;
	}
#endif

	if (ViewType)
	{
		//三人称
		g_Camera.pos.x = GetPlayer()->pos.x - sinf(g_Camera.rot.y) * ThirdPerson.x;
		g_Camera.pos.y = GetPlayer()->pos.y + ThirdPerson.y;
		g_Camera.pos.z = GetPlayer()->pos.z - cosf(g_Camera.rot.y) * ThirdPerson.z;
	}
	else
	{
		//一人称　DirectXの軸→カメラが前だから,+ XM_PI
		g_Camera.pos.x = GetPlayer()->pos.x - sinf(g_Camera.rot.y + XM_PI) * OnePerson.x;
		g_Camera.pos.y = GetPlayer()->pos.y + OnePerson.y;
		g_Camera.pos.z = GetPlayer()->pos.z - cosf(g_Camera.rot.y + XM_PI) * OnePerson.z;
	}

	//DirectXの軸→注視点が前だから, +XM_PI
	g_Camera.at.x = GetPlayer()->pos.x - sinf(g_Camera.rot.y + XM_PI) * g_Camera.len;
	g_Camera.at.y = GetPlayer()->pos.y - sinf(g_Camera_at_rot) * g_Camera.len;
	g_Camera.at.z = GetPlayer()->pos.z - cosf(g_Camera.rot.y + XM_PI) * g_Camera.len;

	SetCamera();

	//カーソルを中心に設定
	//SetCursorPos(SCREEN_CENTER_X, SCREEN_CENTER_Y);

#ifdef _DEBUG

#endif

}


//=============================================================================
// カメラの更新
//=============================================================================
void SetCamera(void)
{
	// ビューマトリックス設定
	XMMATRIX mtxView;
	mtxView = XMMatrixLookAtLH(XMLoadFloat3(&g_Camera.pos), XMLoadFloat3(&g_Camera.at), XMLoadFloat3(&g_Camera.up));
	SetViewMatrix(&mtxView);
	XMStoreFloat4x4(&g_Camera.mtxView, mtxView);

	XMMATRIX mtxInvView;
	mtxInvView = XMMatrixInverse(nullptr, mtxView);
	XMStoreFloat4x4(&g_Camera.mtxInvView, mtxInvView);


	// プロジェクションマトリックス設定
	XMMATRIX mtxProjection;
	mtxProjection = XMMatrixPerspectiveFovLH(VIEW_ANGLE, VIEW_ASPECT, VIEW_NEAR_Z, VIEW_FAR_Z);

	SetProjectionMatrix(&mtxProjection);
	XMStoreFloat4x4(&g_Camera.mtxProjection, mtxProjection);

	SetShaderCamera(g_Camera.pos);
}


//=============================================================================
// カメラの取得
//=============================================================================
CAMERA* GetCamera(void)
{
	return &g_Camera;
}

//=============================================================================
// ビューポートの設定
//=============================================================================
void SetViewPort(int type)
{
	ID3D11DeviceContext* g_ImmediateContext = GetDeviceContext();
	D3D11_VIEWPORT vp;

	g_ViewPortType = type;

	// ビューポート設定
	switch (g_ViewPortType)
	{
	case TYPE_FULL_SCREEN:
		vp.Width = (FLOAT)SCREEN_WIDTH;
		vp.Height = (FLOAT)SCREEN_HEIGHT;
		vp.MinDepth = 0.0f;
		vp.MaxDepth = 1.0f;
		vp.TopLeftX = 0;
		vp.TopLeftY = 0;
		break;

	case TYPE_LEFT_HALF_SCREEN:
		vp.Width = (FLOAT)SCREEN_WIDTH / 2;
		vp.Height = (FLOAT)SCREEN_HEIGHT;
		vp.MinDepth = 0.0f;
		vp.MaxDepth = 1.0f;
		vp.TopLeftX = 0;
		vp.TopLeftY = 0;
		break;

	case TYPE_RIGHT_HALF_SCREEN:
		vp.Width = (FLOAT)SCREEN_WIDTH / 2;
		vp.Height = (FLOAT)SCREEN_HEIGHT;
		vp.MinDepth = 0.0f;
		vp.MaxDepth = 1.0f;
		vp.TopLeftX = (FLOAT)SCREEN_WIDTH / 2;
		vp.TopLeftY = 0;
		break;

	case TYPE_UP_HALF_SCREEN:
		vp.Width = (FLOAT)SCREEN_WIDTH;
		vp.Height = (FLOAT)SCREEN_HEIGHT / 2;
		vp.MinDepth = 0.0f;
		vp.MaxDepth = 1.0f;
		vp.TopLeftX = 0;
		vp.TopLeftY = 0;
		break;

	case TYPE_DOWN_HALF_SCREEN:
		vp.Width = (FLOAT)SCREEN_WIDTH;
		vp.Height = (FLOAT)SCREEN_HEIGHT / 2;
		vp.MinDepth = 0.0f;
		vp.MaxDepth = 1.0f;
		vp.TopLeftX = 0;
		vp.TopLeftY = (FLOAT)SCREEN_HEIGHT / 2;
		break;


	}
	g_ImmediateContext->RSSetViewports(1, &vp);

}


int GetViewPortType(void)
{
	return g_ViewPortType;
}



// カメラの視点と注視点をセット
void SetCameraAT(XMFLOAT3 pos)
{
	// カメラの注視点を引数の座標にしてみる
	g_Camera.at = pos;

	//// カメラの視点をカメラのY軸回転に対応させている
	//g_Camera.pos.x = g_Camera.at.x - sinf(g_Camera.rot.y) * g_Camera.len;
	//g_Camera.pos.z = g_Camera.at.z - cosf(g_Camera.rot.y) * g_Camera.len;

}

